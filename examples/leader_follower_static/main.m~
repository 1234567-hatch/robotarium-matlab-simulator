%% Leader-follower with static topology
% Paul Glotfelter 
% 3/24/2016

%% Experiment Constants

%Run for 300 iterations
iterations = 2000;

%% Set up the Robotarium object

%Get Robotarium object and set the save parameters

r = Robotarium();
N = r.getAvailableAgents();

r.initialize(N);

%% Create the desired Laplacian

%Graph laplacian  
followers = -completeGL(N-1); 
L = zeros(N, N); 
L(2:N, 2:N) = followers;
L(2, 2) = L(2, 2) + 1; 
L(2, 1) = -1; 

%Initialize velocity vector
dxi = zeros(2, N);

%State for leader
state = 0;

%% Grab tools we need to convert from single-integrator to unicycle dynamics

%collisionAvoidanceGain = 0.001; 
formationControlGain = 10;
desiredDistance = 0.09;

% Single-integrator -> unicycle dynamics mapping
si_to_uni_dyn = create_si_to_uni_mapping2('LinearVelocityGain', 1, 'AngularVelocityLimit', 2);
% Single-integrator barrier certificates
si_barrier_cert = create_si_barrier_certificate('SafetyRadius', 0.08);
% Single-integrator position controller 
si_pos_controller = create_si_position_controller();

for t = 1:iterations
           
    % Retrieve the most recent poses from the Robotarium.  The time delay is
    % approximately 0.033 seconds
    x = r.getPoses();
    
    %%% ALGORITHM %%%
    
    for i = 2:N
        
        %Zero velocity and get the topological neighbors of agent i
        dxi(:, i) = [0 ; 0];
        
        neighbors = r.getTopNeighbors(i, L);
        
        for j = neighbors 
            dxi(:, i) = dxi(:, i) + ...
            formationControlGain*(norm(x(1:2, j) - x(:, i))^2 -  desiredDistance^2)*(x(:, j) - x(:, i));
        end      
    end   
    
    %%% END ALGORITHM %%%   
        
    % Make the leader travel between waypoints
    
    switch state 

        case 0             
            dxi(:, 1) = si_pos_controller(x(:, 1), [0.25 ; 0.15]);
            if(norm(x(1:2, 1) - [0.25 ; 0.15]) < 0.05) 
               state = 1; 
            end           
        case 1
            dxi(:, 1) = si_pos_controller(x(:, 1), [-0.25 ; 0.15]);
            if(norm(x(1:2, 1) - [-0.25 ; 0.15]) < 0.05) 
               state = 2; 
            end
        case 2
            dxi(:, 1) = si_pos_controller(xi(:, 1), [-0.25 ; -0.15]);
            if(norm(xi(1:2, 1) - [-0.25 ; -0.15]) < 0.05)
               state = 3; 
            end
        case 3
            dxi(:, 1) = si_pos_controller(xi(:, 1), [0.25 ; -0.15]);
            if(norm(xi(1:2, 1) - [0.25 ; -0.15]) < 0.05)
               state = 0; 
            end
    end

    dxi = si_barrier_cert(dxi, x);
    dxu = si_to_uni_dyn(dxi, x);
    
    %Set velocities 
    r.setVelocities(1:N, dxu);
    
    %Iterate experiment
    r.step();
end